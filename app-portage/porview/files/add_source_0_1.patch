diff --git a/porview.cxx b/porview.cxx
new file mode 100644
index 0000000..c026c76
--- /dev/null
+++ b/porview.cxx
@@ -0,0 +1,665 @@
+//
+// porview, front-end GUI application for portage and gentoolkit
+// Copyright (C) 2020  Dimibyte
+//
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 3
+// of the License, or (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//
+
+// generated by Fast Light User Interface Designer (fluid) version 1.0305
+
+#include "porview.h"
+/*
+TODO:
+----
+1. Tree with columns
+http://seriss.com/people/erco/fltk/#TreeWithColumns
+
+2. Console window
+http://seriss.com/people/erco/fltk/#mkfifo
+
+3. Icon
+
+4. Fixed Group widget for Simple tree window buttons
+http://seriss.com/people/erco/fltk/Fl_Fixed_Group/
+*/
+#define EQUERY_COMMAND "equery -q s"
+
+CAtom::CAtom(std::string N , ull tot , ull una , ull size ) {
+  name = N;
+  total = tot;
+  unaxs = una;
+  size = size;
+}
+
+ull convert_str(const char* str) {
+  char *end;
+  	for (ull i = std::strtoull(str, &end, 10);
+  			str!= end;
+  			i = std::strtoull(str, &end, 10)) {
+  #ifdef DEBUG
+  		std::cout << "'" << std::string(str, end-str) << "' -> ";
+  #endif // DEBUG
+  		str = end;
+  		if (errno == ERANGE) {
+  #ifdef DEBUG
+  			std::cout << "range error, got ";
+  #endif // DEBUG
+  			errno = 0;
+  		}
+  #ifdef DEBUG		
+  		std::cout << i << '\n';
+  #endif // DEBUG
+  		return i;
+  	}
+  	return 0;
+}
+
+const char* convert_kbytes(ull k) {
+  static char buffer[32];
+  int index = 0;
+  double dk = k;
+  while (dk >= 1024.0) {
+    index++;
+    dk /= 1024.0;
+  }
+  if (index)
+    sprintf(buffer, "%.4g%c", dk, "KMGTPEZY"[index]);
+  else
+    sprintf(buffer, "%dK", (int)k);
+  return buffer;
+}
+
+CAtom equery_s_to_atom(std::string str) {
+  typedef boost::tokenizer<boost::char_separator<char> > 
+      tokenizer;
+    boost::char_separator<char> sep("/: (),");
+    tokenizer tokens(str, sep);
+    unsigned int i = 0;
+    CAtom atom;
+    for (tokenizer::iterator tok_iter = tokens.begin();
+         tok_iter != tokens.end(); ++tok_iter) {
+  	switch (i) {
+  	case 0: atom.name = std::string(*tok_iter); break;
+  	case 1: { atom.name += "/"; atom.name += std::string(*tok_iter); } break;
+  	case 3: atom.total = convert_str(tok_iter->c_str()); break;
+  	case 5: atom.unaxs = convert_str(tok_iter->c_str()); break;
+  	case 7: atom.size = convert_str(tok_iter->c_str()); break;
+  	default: break; 
+      }
+  	i++;
+    }
+  #ifdef DEBUG
+    std::cout << "Name: " << atom.name << "\nTotal: " << atom.total << "\nUn: " << atom.unaxs << "\nSize: " << atom.size << "\n";
+  #endif // DEBUG
+    return atom;
+}
+
+std::string get_token(std::string str, const char* separator , int token_num ) {
+  typedef boost::tokenizer<boost::char_separator<char> > 
+      tokenizer;
+  boost::char_separator<char> sep(separator);
+  tokenizer tokens(str, sep);
+  unsigned int i = 0;
+  std::string token;
+  
+  for (tokenizer::iterator tok_iter = tokens.begin();
+  tok_iter != tokens.end(); ++tok_iter) {
+    if ( i == token_num )
+      token = std::string(*tok_iter); 
+  
+    i++;
+  }
+  #ifdef DEBUG
+  std::cout << "Category: " << token.c_str() << "\n";
+  #endif // DEBUG
+  return token;
+}
+// Globals for console display
+/**
+ one display per child
+*/
+Fl_Text_Display *G_disp[6]; 
+/**
+ one buffer per child
+*/
+Fl_Text_Buffer *G_buff[6]; 
+/**
+ read pipe for child's stderr, one per child
+*/
+int G_outfd[6]; 
+/**
+ pid for each child
+*/
+pid_t G_pids[6]; 
+// end of globals
+
+bool string_find(std::string const &string, std::string const &s) {
+  if (string.find(s) == std::string::npos)
+  	return false;
+  else
+  	return true;
+}
+short tick = 0; 
+
+Fl_Double_Window *Sets_Window=(Fl_Double_Window *)0;
+
+Fl_Browser *listOfSets=(Fl_Browser *)0;
+
+Fl_Button *refresh=(Fl_Button *)0;
+
+int main(int argc, char **argv) {
+  Fl::scheme("gtk+");
+  std::cout << FL_ABI_VERSION << std::endl;
+  { // Portage sets display
+    Sets_Window = new Fl_Double_Window(350, 225, "Portage sets display");
+    Sets_Window->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
+    { Fl_Browser* o = listOfSets = new Fl_Browser(20, 30, 310, 110, "Select sets to analyze:");
+      listOfSets->type(2);
+      listOfSets->align(Fl_Align(FL_ALIGN_TOP_LEFT));
+      listOfSets->deactivate();
+      o->selection_color(0x6E56AF00);
+      o->color(0xFAFAFA00);
+    } // Fl_Browser* listOfSets
+    { Fl_Return_Button* o = new Fl_Return_Button(220, 195, 110, 20, "Show usage");
+      o->box(FL_GTK_UP_BOX);
+      o->callback((Fl_Callback*)make_window_CB);
+    } // Fl_Return_Button* o
+    { refresh = new Fl_Button(20, 195, 100, 20, "Refresh list");
+      refresh->box(FL_GTK_UP_BOX);
+      refresh->callback((Fl_Callback*)Button_CB);
+    } // Fl_Button* refresh
+    Sets_Window->end();
+  } // Fl_Double_Window* Sets_Window
+  /*switch(tick) {
+      case 0: progress->value("|"); break;
+      case 1: progress->value("/"); break;
+      case 2: progress->value("--"); break;
+      case 3: progress->value("\\"); break;
+      default: tick = 0; break; } 
+      tick++;
+      if (tick >=4) tick=0;*/
+  Sets_Window->show(argc, argv);
+  return Fl::run();
+}
+
+/**
+ "Refresh list" Button
+*/
+void Button_CB(Fl_Widget *refresh, void *data) {
+  // Deactivate the button
+  refresh->deactivate();
+  Fl::check();	// give fltk some cpu to gray out button
+  // Make the progress bar
+  //Fl_Window *w = (Fl_Window*)data;           // access parent window
+      Sets_Window->begin();                                // add progress bar to it..
+      Fl_Progress *progress = new Fl_Progress(20,160,310,20);
+      progress->minimum(0);                      // set progress range to be 0.0 ~ 1.0
+      progress->maximum(1);
+      progress->color(0xE1E1E100);               // background color
+      progress->selection_color(0x61538D00);     // progress bar color
+      progress->labelcolor(FL_WHITE);            // percent text color
+      Sets_Window->end();                                  // end adding to window
+  Sets_Window->cursor(FL_CURSOR_WAIT);
+  FILE* pipe = popen("emerge --list-sets", "r");
+  if (!pipe) {
+     fl_alert("Problem running 'emerge --list-sets' : %s", strerror(errno));
+  }
+  
+  // Make progress
+  progress->value(0.01);
+  char percent[10];
+  sprintf(percent, "%d%%", int(0.01*100.0));
+  progress->label(percent);
+  Fl::check();
+  tick = 0;
+      
+  io::file_descriptor_source fds(fileno(pipe), io::close_handle);
+  io::stream_buffer<io::file_descriptor_source> fpstream(fds);
+  std::istream in(&fpstream);
+      
+  std::string line;
+  listOfSets->deactivate();
+  listOfSets->clear();
+  listOfSets->begin();
+  listOfSets->add("world");
+  listOfSets->add("system");
+  listOfSets->add("*/*");
+  while (in)
+  {
+      std::getline(in, line);
+  #if DEBUG
+      std::cout << line.length() << std::endl;
+  #endif // DEBUG
+      if (line.length()>0) {
+      if ((line != std::string("world")) || (line != std::string("system"))) {
+      	listOfSets->add(line.c_str());
+      	if (tick < 100) {
+      		tick++;
+      		progress->value(tick/100);
+      		sprintf(percent, "%d%%", int(tick));
+  		progress->label(percent);
+  		Fl::check();
+  	}
+  #if DEBUG
+      	std::cout << line << std::endl;
+  #endif // DEBUG
+      }
+  #if DEBUG
+      std::cout << line << std::endl;
+  #endif // DEBUG
+  }
+  }
+  listOfSets->end();
+  listOfSets->activate();
+  Sets_Window->cursor(FL_CURSOR_DEFAULT);
+  // Cleanup
+      Sets_Window->remove(progress);                       // remove progress bar from window
+      delete(progress);                          // deallocate it
+      refresh->activate();                          // reactivate button
+      Sets_Window->redraw();                               // tell window to redraw now that progress removed
+}
+
+Fl_Double_Window *Simple_Tree_Window=(Fl_Double_Window *)0;
+
+Fl_Tree *simple_tree=(Fl_Tree *)0;
+
+Fl_Value_Output *Total_Value=(Fl_Value_Output *)0;
+
+Fl_Value_Output *Una_Value=(Fl_Value_Output *)0;
+
+Fl_Output *Size_Value=(Fl_Output *)0;
+
+Fl_Input *Search_Input=(Fl_Input *)0;
+
+static void cb_Uninstall(Fl_Button*, void*) {
+  #if FL_ABI_VERSION >= 10303
+// Get selected items as an array
+Fl_Tree_Item_Array items;
+simple_tree->get_selected_items(items);
+// Manipulate the returned array
+for (int t=0; t<items.total(); t++)
+{
+    Fl_Tree_Item item = items[t];
+    std::cout << "Uninstall: " << item.label() << std::endl;
+    item.deactivate();
+}
+#else
+char buf[2048];
+std::string buff;
+for ( Fl_Tree_Item *i = simple_tree->first_selected_item(); i; i = simple_tree->next_selected_item(i) )
+{
+  buff = get_token(i->label());
+  printf("Item %s is selected\n",buff.c_str());
+  //popen(buf, "r");
+}
+#endif
+}
+
+static void cb_Search(Fl_Return_Button*, void*) {
+  simple_tree->deselect_all();
+for ( Fl_Tree_Item *i = simple_tree->first(); i; i = simple_tree->next(i) )
+{
+  if (string_find(i->label(), Search_Input->value()))
+  {
+  	simple_tree->select(i);
+//#ifdef DEBUG
+  	printf("Item %s is selected\n", i->label());
+//#endif //DEBUG
+  	simple_tree->display(i);
+  }
+  
+};
+}
+
+static void cb_Sort(Fl_Button*, void*) {
+  char buf[2048];
+std::string buff;
+ull d[] = { 1750, 701, 301, 132, 57, 23, 10, 4, 1 };
+}
+
+/**
+ Simple tree creation procedure
+*/
+void make_window_CB(Fl_Widget *button, void *data) {
+  Sets_Window->cursor(FL_CURSOR_WAIT);
+  // Deactivate the button
+  button->deactivate();
+  Fl::check();	// give fltk some cpu to gray out button
+  // Make the progress bar
+  //Fl_Window *w = (Fl_Window*)data;           // access parent window
+      Sets_Window->begin();                                // add progress bar to it..
+      Fl_Progress *progress = new Fl_Progress(20,160,310,20);
+      progress->minimum(0);                      // set progress range to be 0.0 ~ 1.0
+      progress->maximum(1);
+      progress->color(0xDDDAEC00);               // background color
+      progress->selection_color(0x61538D00);     // progress bar color
+      progress->labelcolor(FL_WHITE);            // percent text color
+      Sets_Window->end();                                  // end adding to window
+      
+      char percent[10];
+  { // Simple Tree window
+    Simple_Tree_Window = new Fl_Double_Window(500, 650, "Porview");
+    Simple_Tree_Window->align(Fl_Align(FL_ALIGN_CLIP|FL_ALIGN_INSIDE));
+    { Fl_Tree* o = simple_tree = new Fl_Tree(5, 20, 380, 605, "Tree view:");
+      simple_tree->box(FL_GTK_DOWN_BOX);
+      simple_tree->align(Fl_Align(FL_ALIGN_TOP_LEFT));
+      o->selectmode(FL_TREE_SELECT_MULTI);
+    } // Fl_Tree* simple_tree
+    { Total_Value = new Fl_Value_Output(40, 626, 65, 18, "Total:");
+      Total_Value->box(FL_GTK_THIN_DOWN_FRAME);
+      Total_Value->labelsize(12);
+      Total_Value->textsize(13);
+    } // Fl_Value_Output* Total_Value
+    { Una_Value = new Fl_Value_Output(210, 626, 50, 18, "Unaccessable:");
+      Una_Value->box(FL_GTK_THIN_DOWN_FRAME);
+      Una_Value->labelsize(12);
+      Una_Value->textsize(13);
+    } // Fl_Value_Output* Una_Value
+    { Size_Value = new Fl_Output(310, 626, 75, 19, "Size:");
+      Size_Value->box(FL_GTK_THIN_DOWN_FRAME);
+      Size_Value->labelsize(12);
+      Size_Value->textsize(13);
+    } // Fl_Output* Size_Value
+    { Fl_Button* o = new Fl_Button(390, 270, 105, 25, "Clean up");
+      o->tooltip("emerge -cv");
+      o->box(FL_GTK_UP_BOX);
+      o->deactivate();
+    } // Fl_Button* o
+    { Fl_Button* o = new Fl_Button(390, 125, 105, 25, "Set update");
+      o->tooltip("emerge -NuD --exclude \"gcc\"");
+      o->box(FL_GTK_UP_BOX);
+      o->callback((Fl_Callback*)make_console_window_cb);
+      o->deactivate();
+    } // Fl_Button* o
+    { Search_Input = new Fl_Input(390, 21, 105, 24);
+      Search_Input->tooltip("Switch to category");
+      Search_Input->box(FL_GTK_DOWN_BOX);
+      Search_Input->labeltype(FL_NO_LABEL);
+      Search_Input->align(Fl_Align(FL_ALIGN_TOP));
+    } // Fl_Input* Search_Input
+    { Fl_Button* o = new Fl_Button(390, 160, 105, 25, "Uninstall");
+      o->tooltip("Uninstall packages with emerge -c");
+      o->box(FL_GTK_UP_BOX);
+      o->callback((Fl_Callback*)cb_Uninstall);
+      o->deactivate();
+    } // Fl_Button* o
+    { Fl_Return_Button* o = new Fl_Return_Button(390, 45, 105, 25, "Search");
+      o->box(FL_GTK_UP_BOX);
+      o->callback((Fl_Callback*)cb_Search);
+    } // Fl_Return_Button* o
+    { Fl_Button* o = new Fl_Button(390, 595, 105, 25, "Sort by size");
+      o->box(FL_GTK_UP_BOX);
+      o->callback((Fl_Callback*)cb_Sort);
+      o->deactivate();
+    } // Fl_Button* o
+    { Fl_Round_Button* o = new Fl_Round_Button(390, 360, 105, 40, "Without sorting");
+      o->type(102);
+      o->down_box(FL_ROUND_DOWN_BOX);
+      o->align(Fl_Align(132|FL_ALIGN_INSIDE));
+      o->setonly();
+    } // Fl_Round_Button* o
+    { Fl_Round_Button* o = new Fl_Round_Button(390, 405, 105, 40, "Sorting in category");
+      o->type(102);
+      o->down_box(FL_ROUND_DOWN_BOX);
+      o->align(Fl_Align(132|FL_ALIGN_INSIDE));
+      o->deactivate();
+    } // Fl_Round_Button* o
+    { Fl_Round_Button* o = new Fl_Round_Button(390, 450, 105, 40, "Overall sorting");
+      o->type(102);
+      o->down_box(FL_ROUND_DOWN_BOX);
+      o->align(Fl_Align(132|FL_ALIGN_INSIDE));
+      o->deactivate();
+    } // Fl_Round_Button* o
+    Simple_Tree_Window->size_range(400, 300);
+    Simple_Tree_Window->end();
+    Simple_Tree_Window->resizable(Simple_Tree_Window);
+  } // Fl_Double_Window* Simple_Tree_Window
+  const char* nameOfSet;
+  if ((listOfSets->active()) &&
+  // Get selected items as an array
+  /*Fl_Tree_Item_Array items;
+  tree->get_selected_items(items);
+  // Manipulate the returned array
+  for ( int t=0; t<items.total(); t++ ) {
+      Fl_Tree_Item &item = items[t];
+      ..do stuff with each selected item..
+  }*/
+  (listOfSets->value() > 0))
+    nameOfSet = listOfSets->text(listOfSets->value());
+   else
+    nameOfSet = "world";
+    
+    std::cout << "Set: "<< listOfSets->value() << "-" << nameOfSet << "\n";
+  //std::cout << "Set: " << listOfSets->value() << nameOfSet.c_str() << std::endl;
+  // Make tree routine
+  // Execute command
+  char buf[2048];
+  if ( strcmp("*/*", nameOfSet) != 0 )
+  	snprintf(buf, 2048, EQUERY_COMMAND" @%s", nameOfSet);
+  else
+  	snprintf(buf, 2048, EQUERY_COMMAND" */*");
+  FILE* pipe = popen(buf, "r");
+  if (!pipe) {
+     printf("Problem running '%s' : %s", buf, strerror(errno));
+  }
+  // Get command output 
+  io::file_descriptor_source fds(fileno(pipe), io::close_handle);
+  io::stream_buffer<io::file_descriptor_source> fpstream(fds);
+  std::istream in(&fpstream);
+  
+  progress->value(1/5000.0);
+  sprintf(percent, "%d%%", int((1/5000.0)*100.0));
+  progress->label(percent);
+  
+  // Setup variables
+  std::string line;
+  CAtom atom;
+  ull ttl = 0, una = 0, sz = 0, category_sz = 0;
+  tick = 0;
+  // Remember name
+  char buf_name[2048];
+  std::string last_category("first");
+  short counter = 1;
+  
+  
+  
+  //progress->activate();
+  simple_tree->clear();
+  simple_tree->begin();
+  while (in)
+  {
+      std::getline(in, line);
+      if (line.length()>0) {
+      // Split equery output
+      atom = equery_s_to_atom(line);
+      // Get name
+      sprintf(buf_name, "%s    %s", atom.name.c_str(), convert_kbytes(atom.size/1024));
+      // Set details
+      sprintf(buf, "%s/Total files: %llu", buf_name, atom.total);
+  //#if DEBUG
+  //    std::cout << std::string(buf) << std::endl;
+  //#endif // DEBUG
+      ttl += atom.total;
+      simple_tree->add(buf);
+      sprintf(buf, "%s/Unaccessible: %llu", buf_name, atom.unaxs);
+      una += atom.unaxs;
+      simple_tree->add(buf);
+      sprintf(buf, "%s/Total size: %s", buf_name, convert_kbytes(atom.size/1024));
+      sz += atom.size;
+      simple_tree->add(buf);
+      // Close package details
+      simple_tree->close(buf_name);
+      // First category register
+      if ( strcmp("first", last_category.c_str()) == 0 ) {
+      	last_category = get_token(line, "/");
+      	std::cout << " first cat: " << last_category.c_str() << "\n";}
+      // Next category checks
+      if ( strcmp(get_token(line, "/").c_str(), last_category.c_str()) != 0 )
+      {
+      	// Write down category size
+      	std::cout <<  last_category.c_str() << ": " << category_sz << " (" << convert_kbytes(category_sz/1024)<< ")" << std::endl;
+      	sprintf(buf, "Total size: %s", convert_kbytes(category_sz/1024));
+      	simple_tree->insert(simple_tree->find_item(last_category.c_str()), buf, 0);
+      	category_sz = 0;
+      	category_sz += atom.size;
+      } else {
+      	category_sz += atom.size;
+      } 
+      last_category = get_token(line,"/");
+      
+      if (tick < 5000) {
+      	tick++;
+      	progress->value(tick/5000.0);
+      	sprintf(percent, "%d%%", int((tick/5000.0)*100.0));
+  	progress->label(percent);
+  	Fl::check();
+  //	std::cout << "   " << tick/5000.0;
+      }
+  
+     
+  //#if DEBUG
+  //    std::cout << line << std::endl;
+  //#endif // DEBUG
+      }
+      
+  }
+  // Last category size
+  sprintf(buf, "Total size: %s", convert_kbytes(category_sz/1024));
+  simple_tree->insert(simple_tree->find_item(last_category.c_str()), buf, 0);
+  
+  simple_tree->root_label(nameOfSet);
+  simple_tree->end();
+  Total_Value->value(ttl);
+  Una_Value->value(una);
+  Size_Value->value(convert_kbytes(sz/1024));
+  //progress->deactivate();
+  //#if DEBUG
+  simple_tree->show_self();
+  //#endif // DEBUG
+  snprintf(buf, 2048, "porview @%s", nameOfSet);
+  Simple_Tree_Window->label(buf);
+  Simple_Tree_Window->show();
+  //while (Simple_Tree_Window->damage()) Fl::wait(.1);
+  Sets_Window->cursor(FL_CURSOR_DEFAULT);
+  // Cleanup
+      Sets_Window->remove(progress);                       // remove progress bar from window
+      delete(progress);                          // deallocate it
+      button->activate();                          // reactivate button
+      Sets_Window->redraw();                               // tell window to redraw now that progress removed
+}
+
+/**
+ Start child process,
+ makes a read pipe to its stderr
+*/
+void start_child(int t) {
+  int out[2]; if (pipe(out) < 0) exit(1);
+      switch ( ( G_pids[t] = fork() ) ) {
+          case -1: // Error
+              close(out[0]); close(out[1]);
+              perror("fork()");
+              exit(1);
+          case 0: // Child
+              close(out[0]); dup2(out[1], 2); close(out[1]);
+              switch (t) {
+                  case 0: execlp("/bin/sh", "sh", "-c", "ps auxww 1>&2",0);
+                          perror("execlp(ps)");
+                          exit(1);
+                  case 1: execlp("/bin/sh", "sh", "-c", "perl -e 'for($t=0; sleep(1); $t++)"
+                                 "{print STDERR rand().\"\\n\"; if ($t>5) {kill(9,$$);}}' 1>&2", 0);
+                          perror("execlp(perl)");
+                          exit(1);
+                  case 2: execlp("/bin/sh", "sh", "-c", "(ls -la; ping -c 8 localhost) 1>&2", 0);
+                          perror("execlp(ls/ping)");
+                          exit(1);
+                  default: exit(1);
+              }
+          default: // Parent
+              G_outfd[t] = out[0]; close(out[1]);
+              return;
+      }
+}
+
+/**
+ Data ready interrupt
+*/
+void data_ready(int fd, void* data) {
+  int t = *(int*)data;
+      char s[4096];
+      int bytes = read(fd, s, 4096-1);
+      printf("Data ready for %d) pid=%ld fd=%d bytes=%d\n", t, (long)G_pids[t], fd, bytes);  
+      if ( bytes == -1 ) {                // ERROR
+          perror("read()");
+      } else if ( bytes == 0 ) {          // EOF
+          G_buff[t]->append("\n\n*** EOF ***\n");
+          int status;
+          if ( waitpid(G_pids[t], &status, WNOHANG) < 0 ) {
+              sprintf(s, "waitpid(): %s\n", strerror(errno));
+          } else {
+              if ( WIFEXITED(status) ) {
+                  sprintf(s, "Exit=%d\n", WEXITSTATUS(status));
+                  close(fd); Fl::remove_fd(fd); G_pids[t] = -1;
+              } else if ( WIFSIGNALED(status) ) {
+                  sprintf(s, "Killed with %d\n", WTERMSIG(status));
+                  close(fd); Fl::remove_fd(fd); G_pids[t] = -1;
+              } else if ( WIFSTOPPED(status) ) {
+                  sprintf(s, "Stopped with %d\n", WSTOPSIG(status));
+              }
+          }
+          G_buff[t]->append(s);
+      } else {                            // DATA
+          s[bytes] = 0;
+          G_buff[t]->append(s);
+      }
+}
+
+/**
+ Clean up if someone closes the window
+*/
+void close_cb(Fl_Widget*, void*) {
+  printf("Killing child processes..\n");
+      for ( int t=0; t<3; t++ ) {
+          if ( G_pids[t] == -1 ) continue;
+          kill(G_pids[t], 9);
+      }
+      printf("Done.\n");
+      exit(0);
+}
+
+Fl_Double_Window *console_window=(Fl_Double_Window *)0;
+
+/**
+ Console window creation
+*/
+void make_console_window_cb(Fl_Widget*, void*) {
+  { console_window = new Fl_Double_Window(620, 520, "fltk-tty");
+    console_window->callback((Fl_Callback*)close_cb);
+    console_window->end();
+    console_window->resizable(console_window);
+  } // Fl_Double_Window* console_window
+  // Start children, one tty for each
+  for ( int t=0; t<3; t++ ) {
+          start_child(t);
+          console_window->begin();
+          G_buff[t] = new Fl_Text_Buffer();
+          G_disp[t] = new Fl_Text_Display(10+t*200, 10, 200, 500);
+          G_disp[t]->buffer(G_buff[t]);
+          G_disp[t]->textfont(FL_COURIER);
+          G_disp[t]->textsize(12);
+          Fl::add_fd(G_outfd[t], data_ready, (void*)&t);
+          console_window->end();
+  }
+  console_window->show();
+}
diff --git a/porview.h b/porview.h
new file mode 100644
index 0000000..0cdbf45
--- /dev/null
+++ b/porview.h
@@ -0,0 +1,100 @@
+//
+// porview, front-end GUI application for portage and gentoolkit
+// Copyright (C) 2020  Dimibyte
+//
+// This program is free software; you can redistribute it and/or
+// modify it under the terms of the GNU General Public License
+// as published by the Free Software Foundation; either version 3
+// of the License, or (at your option) any later version.
+//
+// This program is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+//
+// You should have received a copy of the GNU General Public License
+// along with this program; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+//
+
+// generated by Fast Light User Interface Designer (fluid) version 1.0305
+
+#ifndef porview_h
+#define porview_h
+#include <FL/Fl.H>
+/*
+TODO:
+----
+1. Tree with columns
+http://seriss.com/people/erco/fltk/#TreeWithColumns
+
+2. Console window
+http://seriss.com/people/erco/fltk/#mkfifo
+
+3. Icon
+
+4. Fixed Group widget for Simple tree window buttons
+http://seriss.com/people/erco/fltk/Fl_Fixed_Group/
+*/
+#include <sys/types.h>
+#include <sys/wait.h>
+#include <errno.h>
+#include <unistd.h>
+#include <cstdio>
+#include <string>
+#include <iostream>
+#include <any>
+#include <boost/iostreams/device/file_descriptor.hpp>
+#include <boost/iostreams/stream.hpp>
+#include <boost/tokenizer.hpp>
+#include <FL/fl_ask.H>
+#include <FL/Fl_Progress.H>
+#include <FL/Fl_Text_Display.H>
+namespace io = boost::iostreams; 
+typedef unsigned long long ull;
+
+class CAtom {
+public:
+  std::string name; 
+  ull total; 
+  ull unaxs; 
+  ull size; 
+  CAtom(std::string N = std::string(""), ull tot = 0, ull una = 0, ull size = 0);
+};
+ull convert_str(const char* str);
+const char* convert_kbytes(ull k);
+CAtom equery_s_to_atom(std::string str);
+std::string get_token(std::string str, const char* separator = " ", int token_num = 0);
+// Globals for console display
+extern Fl_Text_Display *G_disp[6]; 
+extern Fl_Text_Buffer *G_buff[6]; 
+extern int G_outfd[6]; 
+extern pid_t G_pids[6]; 
+// end of globals
+bool string_find(std::string const &string, std::string const &s);
+#include <FL/Fl_Double_Window.H>
+extern Fl_Double_Window *Sets_Window;
+#include <FL/Fl_Browser.H>
+extern Fl_Browser *listOfSets;
+#include <FL/Fl_Return_Button.H>
+#include <FL/Fl_Button.H>
+extern Fl_Button *refresh;
+void Button_CB(Fl_Widget *refresh, void *data);
+extern Fl_Double_Window *Simple_Tree_Window;
+#include <FL/Fl_Tree.H>
+extern Fl_Tree *simple_tree;
+#include <FL/Fl_Value_Output.H>
+extern Fl_Value_Output *Total_Value;
+extern Fl_Value_Output *Una_Value;
+#include <FL/Fl_Output.H>
+extern Fl_Output *Size_Value;
+#include <FL/Fl_Input.H>
+extern Fl_Input *Search_Input;
+#include <FL/Fl_Round_Button.H>
+void make_window_CB(Fl_Widget *button, void *data);
+void start_child(int t);
+void data_ready(int fd, void* data);
+void close_cb(Fl_Widget*, void*);
+extern Fl_Double_Window *console_window;
+void make_console_window_cb(Fl_Widget*, void*);
+#endif
